/*
 * Copyright (c) 2017. iDoc LLC
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     (1) Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *     (2) Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *
 *     (3)The name of the author may not be used to
 *     endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.attribute.BasicFileAttributes
import java.nio.file.attribute.FileTime

plugins {
	id "com.moowork.node" version "0.13"
}

//version "0.3"
//group "org.samopal"

//project.ext.set("prDir", project.getProjectDir().getAbsolutePath()+"")
project.ext.set("tmpDir", project.getProjectDir().getAbsolutePath()+"/widget")
//project.ext.set("distDir", "/var/www/papka")
project.ext.set("distPath", hasProperty('staticDistributionPath') ? property('staticDistributionPath') : project.getProjectDir().getAbsolutePath()+"/hdDist")
project.ext.set("debug", true)
project.ext.set("nodeDir", 'bower_modules')
project.ext.set("npmCacheDir", new File("${gradle.getGradleUserHomeDir()}/caches/npm").absolutePath)

//repositories {
//    mavenLocal()
//}
node {
	version = '10.15.3'
	download = true
	npmVersion = '6.4.1'
	workDir = file(npmCacheDir)
	nodeModulesDir = file(nodeDir)
}

deploy.enabled=false

def allJsModules = [
		project.prDir+"/src/js/widget.js",
		project.prDir+"/src/js/StompOverSock.js",
		project.prDir+"/src/js/sockjs.js",
]

npm_update {
	args = ['--production', '--loglevel', 'warn']
}

//task clean(type: Delete) {
//   delete project.distPath, project.buildDir, 'node_modules', 'bower_components', tmpDir
//}

task del(type: Delete) {
	delete project.distPath, project.buildDir, 'node_modules', 'bower_components', tmpDir
}
clean.dependsOn.add(del)


task createAllJs(type: NodeTask) {
	script = file(project.prDir+'/node_modules/uglify-es/bin/uglifyjs')
	println "######################## createAllJs ########################"
	println "debug = "+debug
	if (debug) {
		args << "-b"
	} else {
		args << "-m"
	}
	args << '--screw-ie8'
	args << '-o'
	args << project.tmpDir + "/js/all.js"
	// args << "./src/js/version.js" // autogenerated file
	args.addAll(allJsModules)
}

createAllJs.onlyIf {
	println '*** *** *** START *** *** ***'
	println project.tmpDir
	println '*** *** *** FINISH *** *** ***'
	def result = Paths.get("${project.tmpDir}/js/all.js");
	if (Files.exists(result)) {
		FileTime ts = FileTime.fromMillis(0);
		allJsModules.forEach({ String file ->
			FileTime ts1 = Files.readAttributes(Paths.get(file), BasicFileAttributes.class).lastModifiedTime()
			if (ts1 > ts) ts = ts1
		})
		return Files.readAttributes(result, BasicFileAttributes.class).lastModifiedTime() < ts;
	} else {
		return true
	}
}

task syncHtml(type: Copy) {
	it.dependsOn npm_install
	from project.prDir+"/src"
	into project.tmpDir
	include '*.html'

	List<String> list = []
	if (!debug) {
		eachFile({ FileCopyDetails file ->
			if (!Files.exists(Paths.get(project.tmpDir + "/" + file.getRelativePath()))){
				list << project.tmpDir + "/" + file.getPath()
			} else {
				FileTime td = Files.readAttributes(Paths.get(project.tmpDir + "/" + file.getRelativePath()), BasicFileAttributes.class).lastModifiedTime()
				FileTime ts = Files.readAttributes(Paths.get(project.prDir+"/src/" + file.getPath()), BasicFileAttributes.class).lastModifiedTime()
				if (ts > td) {
					list << project.tmpDir + "/" + file.getPath()
				} else {
					file.exclude()
				}
			}
		})
	}

	doLast {
		list.each { String fileName ->
			println "Compress: $fileName"
			exec {
				executable = 'node'
				args = [project.prDir+'/node_modules/html-minify/bin/htmlminify', '-o', fileName, fileName];
			}
		}
	}
}

task syncRes(type: Copy) {
	it.dependsOn syncHtml
	from project.prDir+"/src"
	into project.tmpDir
	include 'fonts/**'
	include 'pdf/**'
	include 'img/**'
	include 'templates/*.html'
	include 'favicon.ico'
	include 'robots.txt'
}

task buildFront() {
	it.dependsOn createAllJs
	it.dependsOn syncRes
	doLast {
		delete project.prDir+'/src/js/version.js'

		copy {
			from project.prDir+"/src/js/xlsx.core.min.js"
			into project.tmpDir + "/js/"
		}
		copy {
			from "./src/css/padmin.css"
			into project.tmpDir + "/css/"
		}
	}
}
build.dependsOn.add(buildFront)

task dist(type: Sync) {
	it.dependsOn build
	from project.tmpDir
	into project.distPath
//	preserve{
//		include 'plugin/**'
//		include 'cryptoplugin.cab'
//	}
}

task makedirs() {
	doLast {
		new File("${project.tmpDir}/css/").mkdirs()
		new File("${project.tmpDir}/js/").mkdirs()
	}
}

def needBuildAllCSS = true;
def result2 = new File("${project.tmpDir}/css/all.css");
//def result2 = Paths.get("${project.tmpDir}/css/all.css");
if (result2.exists()) {
	FileTime ts = FileTime.fromMillis(0);
	fileTree(dir: project.prDir+"/src/style", include: "*").forEach({ File file ->
		FileTime ts1 = Files.readAttributes(file.toPath(), BasicFileAttributes.class).lastModifiedTime()
		if (ts1 > ts) ts = ts1
	})
	needBuildAllCSS = Files.readAttributes(result2.getAbsoluteFile().toPath(), BasicFileAttributes.class).lastModifiedTime() < ts;
}

task buildCSS(type: NodeTask) {
	it.dependsOn npm_install
	it.dependsOn makedirs

	new File("${project.buildDir}/css").mkdirs()
	build.dependsOn it
	script = file(project.prDir+"/node_modules/stylus/bin/stylus")
	args = ['-u', 'nib', project.prDir+'/src/style/widget.styl', '--out', "${project.tmpDir}/css/all.css"]
	if (project.debug) {
		args << "--line-numbers" << "--firebug"
	} else {
		args << "--compress"
	}
}


remotes {
	webPoligon {
		//role 'masterNode'
		host = '10.56.2.228'
		user = 'sybase'
		identity = file(getProperty('ssh.key.path'))
		//password='Un1W1n123'
	}
}


install {
	it.dependsOn build
	def staticHome =  project.hasProperty('static.home') ? getProperty('static.home'):'/sybase/www/helpdesk.widget.test'
	doLast {
		ssh.run {
			session(remotes.webPoligon) {
				def date = new Date().getTime()
				println "######################## Start uploading new static data ########################"
				def mkDir = "mkdir ${staticHome}"
				remove "${staticHome}"
				execute mkDir
				put from: project.tmpDir, into: "${staticHome}"
				println "######################## Finish uploading new static data at "+(new Date().getTime() - date)+" ms ########################"
			}
		}
	}
}




